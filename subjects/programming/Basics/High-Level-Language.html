  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Level Languages</title>

    <link rel="stylesheet" href="/Assets/Style.css">
</head>
<body>

<div class="section">
<h2>Introduction to High-Level Languages</h2>
<h3>ğŸ’¡ Why high-level languages were created</h3>
<p>Low-level languages (machine code + assembly) are:</p>
<ul>
  <li>hard to write</li>
  <li>hard to understand</li>
  <li>not portable</li>
  <li>require deep CPU knowledge</li>
</ul>
<p>So humans created <b>high-level languages</b> (C, C++, Pascal, Java, JavaScript, Perl...).</p>
<p>These languages:</p>
<ul>
  <li>hide hardware details</li>
  <li>are easy to read</li>
  <li>are portable</li>
  <li>let you write complex programs with fewer lines</li>
</ul>
<hr>
<h3>ğŸ“ Example</h3>
<p>Machine/assembly version earlier:<br> <code>mov al, 0x61</code></p>
<p>Same thing in C/C++:</p>
<pre class="code-box">
<code>
a = 97;
</code>
</pre>
<hr>
<h3>ğŸ”§ High-level code MUST be translated</h3>
<p>The CPU cannot understand high-level code.<br>
So before running, it must be turned into machine code.</p>
<p>Two ways:</p>
<ol>
  <li>Compiling</li>
  <li>Interpreting</li>
</ol>
<hr>
<h3>1ï¸âƒ£ Compiling (C++ works this way)</h3>
<p>A compiler:</p>
<ul>
  <li>reads your high-level code</li>
  <li>translates it into machine code</li>
  <li>produces an <b>executable file</b>.</li>
</ul>
<p>You can run the executable directly on hardware without needing the compiler installed.</p>
<h4>âš™ï¸ Compilers today</h4>
<ul>
  <li>Old compilers â†’ slow, basic code</li>
  <li>Modern compilers â†’ extremely optimized, sometimes even better than humans</li>
</ul>
<hr>
<h3>ğŸ“˜ Optional Reading</h3>
<p>â€œMost C++ compilers can also generate assembly codeâ€¦â€</p>
<p><b>Normally:</b> compiler converts C++ â†’ Machine Code.</p>
<p>But you can also ask for:</p>
<p><b>C++ â†’ Assembly â†’ Machine Code</b></p>
<p><b>Reasons:</b></p>
<ul>
  <li><b>See exactly what the CPU instructions look like</b></li>
  <li><b>Performance tuning</b> (â€œIs compiler generating efficient instructions?â€)</li>
  <li><b>Assembly is easier to read than raw machine code</b></li>
</ul>
<p>Machine code example:<br>
<code>10110000 01100001</code><br>
is unreadable.</p>
<p>Assembly version:<br>
<code>mov al, 0x61</code><br>
is readable.</p>
<hr>
<h3>ğŸ”¥ So what's the core idea?</h3>
<p>A C++ compiler can show the assembly it produced before turning it into machine code.</p>
<p>This helps with:</p>
<ul>
  <li>learning</li>
  <li>debugging</li>
  <li>optimization</li>
  <li>low-level understanding</li>
</ul>
<p>Most programmers never need this.<br>
Advanced coders sometimes check it.</p>
<hr>
<h3>ğŸ“Œ Here is the simplified representation of compiling process:</h3>

<img class="diagram" src="https://www.learncpp.com/images/CppTutorial/Chapter0/Compiling-min.png" alt="Compiling Diagram">
<hr>
<h3>2ï¸âƒ£ Interpreting</h3>

<p>An interpreter:</p>
<ul>
  <li>reads the high-level code</li>
  <li>executes it <b>directly</b>, line by line</li>
  <li>does <b>NOT</b> produce an executable</li>
</ul>

<p>Examples: Python, JavaScript (browsers)</p>

<p>Interpreters are:</p>
<ul>
  <li>more flexible</li>
  <li>slower (translation happens every run)</li>
  <li>must be installed on every machine running the program</li>
</ul>
<hr>
<h3>ğŸ“˜ Here is a simplified representation of interpretation process:</h3>

<img class="diagram" src="https://www.learncpp.com/images/CppTutorial/Chapter0/Interpreting-min.png" alt="Interpreting Diagram">
<hr>
<p>
Most high-level languages can be either compiled or interpreted.  
C, C++, Pascal â†’ compiled  
Perl, JavaScript â†’ interpreted  
Java â†’ mixed system  
</p>
</div>   

<div class="section">
  <h2>The Benefits of High-Level Languages</h2>

  <h3>1ï¸âƒ£ High-level = High abstraction</h3>
  <p>High-level languages hide the hardware details.</p>

  <p>Example:</p>
  <div class="code-box">
    <pre><code class="language-cpp">a = 97;</code></pre>
  </div>

  <p>You donâ€™t need to know:</p>
  <ul>
    <li>which register to use</li>
    <li>where memory is</li>
    <li>which machine instruction stores 97</li>
  </ul>

  <p>The <strong>compiler</strong> handles all that.</p>
  <p>Nothing in <code>a = 97;</code> is tied to any CPU architecture â€” itâ€™s platform-independent.</p>

  <h3>2ï¸âƒ£ High-level = Portable</h3>
  <p>You can write <strong>one C++ program</strong>, and as long as the platform has a C++ compiler, it can be compiled there.</p>

  <p>Thatâ€™s why high-level programs can be:</p>
  <ul>
    <li>portable</li>
    <li>cross-platform - designed to run on multiple platforms</li>
  </ul>

  <h3>3ï¸âƒ£ High-level = Easier to read, write, and learn</h3>
  <p>The instructions look similar to:</p>
  <ul>
    <li>math</li>
    <li>English-like expressions</li>
  </ul>

  <p>Example:</p>
  <div class="code-box">
    <pre><code class="language-cpp">a = b * 2 + 5;</code></pre>
  </div>

  <p>In assembly, the same line needs <strong>4 to 6 separate instructions</strong>.</p>

  <p>High-level languages:</p>
  <ul>
    <li>use fewer lines</li>
    <li>are more concise</li>
    <li>easier to understand</li>
  </ul>

  <h3>4ï¸âƒ£ High-level languages offer more built-in capabilities</h3>
  <p>They simplify common tasks like:</p>
  <ul>
    <li>requesting memory</li>
    <li>searching text</li>
    <li>string manipulation</li>
    <li>working with complex data structures</li>
  </ul>

  <p>Example:<br>
  To check if <code>"abc"</code> exists inside a big block of text:<br>
  In high-level languages â†’ <strong>1 instruction</strong><br>
  In low-level languages â†’ many steps, loops, and checks.</p>

  <p>This reduces:</p>
  <ul>
    <li>complexity</li>
    <li>development time</li>
    <li>programmer effort</li>
  </ul>
</div>
</body>
</html>
