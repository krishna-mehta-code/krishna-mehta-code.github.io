<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Assembly Languages </title>

    <link rel="stylesheet" href="/Assets/Style.css">
</head>
<body> 

<div class="section">
    <h2> Assembly Language</h2>
    <h3>ğŸ–¥ï¸ Why Assembly Exists</32>

    <p>Machine language (like <code>10110000 01100001</code>) is perfect for the <strong>CPU</strong>, but horrible for <strong>humans</strong> to read or write.</p>

    <p>Since humans write programs, we needed something easier.  
    Thatâ€™s where <strong>assembly language</strong> comes in.</p>

    <hr>

    <h3>ğŸ§© What is Assembly Language?</h3>

    <p><strong>Assembly = a human-readable version of machine language.</strong></p>

    <p>Every assembly instruction corresponds directly to a machine instruction.</p>

    <p><strong>Binary machine code:</strong></p>

    <div class="code-box">10110000 01100001</div>

    <p><strong>Same thing in x86 assembly:</strong></p>

    <div class="code-box">mov al, 0x61</div>

    <p>Much easier to read, right?</p>

    <hr>

    <h3>ğŸ“¦ Why Assembly is Easier</h3>

    <h3>1ï¸âƒ£ Easy-to-understand operation names</h3>
    <ul>
        <li>Assembly uses <strong>mnemonics</strong> instead of random 1s and 0s.</li>
        <li>Example: <code>mov</code> = â€œmove dataâ€.</li>
    </ul>

    <h3>2ï¸âƒ£ Registers have names</h3>
    <ul>
        <li>The CPU has small fast memory units called <strong>registers</strong>.</li>
        <li>In x86, one register is named <strong>al</strong>.</li>
    </ul>

    <h3>3ï¸âƒ£ Numbers are written normally</h3>
    <ul>
        <li>Decimal â†’ <code>97</code></li>
        <li>Hexadecimal â†’ <code>0x61</code> (close to binary but easier)</li>
    </ul>

    <h3>ğŸ“Œ Example explained fully</h3>

    <p><strong>Instruction:</strong></p>
    <div class="code-box">mov al, 0x61</div>

    <p><strong>Meaning:</strong></p>
    <ul>
        <li>Copy the number <strong>0x61</strong> into the register <strong>al</strong>.</li>
    </ul>

    <p>This performs the same action as the earlier binary instruction.</p>

    <hr>

    <h3>ğŸ›‘ But CPUs still canâ€™t run Assembly</h3>

    <p>Even though assembly is readable, CPUs only run <strong>machine code</strong>.</p>

    <p>So assembly must be <strong>translated</strong> into machine language using an <strong>assembler</strong>.</p>

    <p>The assembler converts each assembly instruction into its corresponding binary instruction.  
    Since assembly mirrors machine code, this translation is straightforward.</p>

    <hr>

    <h3>ğŸ§¬ CPU Families & Their Own Assembly</h3>

    <p>Just like machine languages differ, <strong>every CPU family has its own assembly language</strong>.</p>

    <ul>
        <li>x86 CPUs â†’ x86 assembly</li>
        <li>ARM CPUs â†’ ARM assembly</li>
        <li>RISC-V â†’ RISC-V assembly</li>
    </ul>

    <p>They may look similar, but:</p>

    <ul>
        <li>syntax differs</li>
        <li>instructions differ</li>
        <li>register names differ</li>
    </ul>

    <p><strong>A program in one assembly language cannot run on another CPU family.</strong></p>

    <hr>

    <h3>â­ Final One-line Summary</h3>

    <p><strong>Assembly = human-friendly machine language, but still unique to each CPU family and needs an assembler to convert it into machine code.</strong></p>

</div>
</body>
</html>
